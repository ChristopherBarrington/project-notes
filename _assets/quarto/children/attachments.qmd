<!-- include attachments, if `report.attachments` is in the metadata -->

```{r appendix-attachments}
#| cache: false
#| echo: false
#| eval: !expr rmarkdown::metadata |> purrr::pluck('report', 'attachments') |> is.null() |> magrittr::not()
#| results: asis

#
# example front matter:
#
# ---
# report:
#   attachments:
#     - directory/file.format
# ---
#

local({
	destination <- 'share'
	stage_type  <- 'ln' # ln or cp

	rmarkdown::metadata |>
		purrr::pluck('report', 'attachments', .default=list()) -> expected_attachments

	expected_attachments |>
		fs::file_exists() |>
		(\(x) x[x])() |>
		names() -> attachments

	expected_attachments |>
		setdiff(attachments) -> missing_attachments

	## ---- get-callout-if-missing-attachments

	missing_attachments_callout <- NULL
	if(length(missing_attachments) > 0)
		c('::: {.callout-warning title="Some expected attachments were not found!"}',
		  {missing_attachments |> as.list() |> yaml::as.yaml()},
		  ':::') -> missing_attachments_callout

	## ---- stage-targets

	stage_target <- function(target, destination, stage_type) {
		if(stringr::str_detect(target, stringr::str_glue('^{destination}/'))) # do nothing if the target is already in the destination
			return()

		dir.create(path=destination, showWarnings=FALSE, recursive=TRUE)

		if(stage_type == 'cp') {
			stringr::str_glue('rm --recursive --force {destination}/{target} ',
				          '&& mkdir --parents {destination}/{target} && rmdir $_',
				          '&& cp --recursive --parents --dereference {target} {destination}') |> system()
		} else if(stage_type == 'ln') {
			hardlink_target_files <- function(target) {
				destination_link <- file.path(destination, target)
				destination_path <- dirname(destination_link)

				stringr::str_glue('mkdir --parents {destination_path} ',
				                  '&& rm --force {destination_link} ',
				                  '&& ln {target} {destination_link}') |> system()
			}

			list.files(path=target, full.names=TRUE, recursive=TRUE) |>
				plyr::l_ply(hardlink_target_files)
		}
	}

	plyr::l_ply(attachments, stage_target, destination=destination, stage_type=stage_type)

	## ---- remove-leading-destination
	# any shared outputs that were written to {destination} need the {desination} removed for the generalised link to work

	attachments |>
		stringr::str_remove(pattern=stringr::str_glue('^{destination}/')) -> attachments

	## ---- attach-targets

	stringr::str_glue('{{{{< fa paperclip >}}}} [{attachments}]({destination}/{attachments})</br>') |>
		append('## Attachments {.appendix}\n', after=0) |>
		append(c(missing_attachments_callout, ''), after=1) |>
		cat(sep='\n')})
```
